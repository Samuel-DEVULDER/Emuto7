/*
                    TTTTTTT    OOOOO    7777777
                       T      O     O        7
                       T      O     O       7     77777  000
                       T      O     O      7         7  0   0
                       T      O     O     7         7   0   0
                       T       OOOOO     7         7     000

                             EMULATEUR

                          Par Sylvain HUET
                    (Sylvain.Huet@inria.fr)
                               1996

  video_ami.c : routines video de l'emulateur (+gestion memoire)

  Adaptation pour l'Amiga par Samuel Devulder en 07/97.
*/

#include <time.h>
#include <signal.h>

#include <exec/memory.h>
#include <exec/devices.h>
#include <exec/io.h>
#include <dos/dos.h>
#include <devices/timer.h>
#include <devices/audio.h>

/* #include <proto/alib.h> le SAS trouve l'include */
#include <proto/exec.h>
#include <proto/intuition.h>
#include <proto/graphics.h>

#include "monitor.h"
#include "emuto7.h"

#define nbtouche 68
#define nkey 3

//int etext;

static UBYTE codel[]=
{0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x04,0x08,0x10,0x20,0x40,0x80
   ,0x04,0x08,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10
     ,0x04,0x08,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10
       ,0x04,0x08,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10
         ,0x02,0x04,0x02,0x04,0x08,0x80
           ,0x04,0x08,0x04,0x08,0x10,0x20,0x40,0x08
             ,0x00,0x00,0x00,0x00,0x00
               ,0x00,0x00,0x00,0x00,0x00
};
static UBYTE codec[]=
{0x01,0x01,0x80,0x40,0x20,0x10,0x08,0x02,0x02,0x02,0x02,0x02,0x02,0x02
   ,0x80,0x80,0x80,0x80,0x80,0x80,0x40,0x40,0x40,0x40
     ,0x20,0x20,0x20,0x20,0x20,0x20,0x10,0x10,0x10,0x10
       ,0x08,0x08,0x08,0x08,0x08,0x08,0x04,0x04,0x04,0x04
         ,0x01,0x01,0x04,0x04,0x04,0x01
           ,0x40,0x40,0x10,0x10,0x01,0x01,0x01,0x01
             ,0xfe,0xfb,0xfd,0xf7,0x1
               ,0xef,0xbf,0xdf,0x7f,0x2
};

struct IntuitionBase    *IntuitionBase;
struct GfxBase          *GfxBase;

static struct Screen    *S;
static struct Window    *W;

static unsigned char decode[256][4];
static unsigned short pal[] = {
    0xAAA,0xFAA,0xAFA,0xFFA,0xAAF,0xFAF,0xAFF,0xFA0,
    0x000,0xF00,0x0F0,0xFF0,0x00F,0xF0F,0x0FF,0xFFF
};

static char whichchannel[]={1,2,4,8};
static struct IOAudio *AudioIO;
static struct MsgPort *AudioMP;
static struct Message *AudioMSG;
static int    iosent,devopen;
static UWORD  *audiobuf;

int     tch[nkey];
int     lkey[256];
int     ckey[256];
static FILE    *fl;
FILE    *fk7;
int     crayx,crayy;
int     lasttour;

int nbwait;

int gainit;
int pa1,pb1;

int     pain1,paout1,crain1;
int     pbin1,pbout1,crbin1;

int     pain2,paout2,crain2;
int     pbin2,pbout2,crbin2;

void inicray(void)
{
  crayx=-1;
}

void inikey(char *name)
{
  int   i,key;

  for(i=0;i<256;i++)
    {
      lkey[i]=0;
      ckey[i]=255;
    }
  tch[0]=tch[1]=0;

  if (fl=fopen(name,"r"))
    {
      for(i=0;i<nbtouche;i++)
        {
          fscanf(fl,"%d",&key);
          lkey[key&255]=codel[i];
          ckey[key&255]=(~codec[i])&255;
        }
      fclose(fl);
    }
  else
    {
      printf("lancer d'abord enterkey\n");
      exit(0);
    }
  buf[0xe7cc]=0;
  buf[0xe7cd]=0;
  buf[0xe7ce]=0;
  buf[0xe7cf]=0;
}

void newcass(char *c)
{
  if (fk7) fclose(fk7);
  if ((fk7=fopen(c,"r+"))==NULL) fk7=fopen(c,"w+");
  if (fk7==NULL) if (fk7=fopen(c,"r")) printf("LECTURE SEULE\n");
  if (fk7==NULL) printf("impossible\n");
  else
    printf("cassette %s\n",c);
}

void avanck7(long k)
{
  if (fk7==NULL)
    printf("impossible\n");
  else
    {
      fseek(fk7,k,0);
      printhx(ftell(fk7),4);
      printf(" : nouvelle position\n");
    }
}

void inik7(void)
{
  fk7=NULL;
}

void gfxleave(void)
{
    if(iosent) {AbortIO((void*)AudioIO);iosent   = 0;}
    if(devopen) {CloseDevice((void*)AudioIO);devopen = 0;}
    if(AudioIO) {DeleteExtIO((void*)AudioIO);AudioIO = NULL;}
    if(AudioMP) {DeleteMsgPort((void*)AudioMP);AudioMP  = NULL;}
    if(audiobuf) {FreeMem((APTR)audiobuf,2);audiobuf = 0;}
    if(W) {CloseWindow((void*)W);W = NULL;}
    if(S) {CloseScreen((void*)S);S = NULL;}
    if(IntuitionBase) {CloseLibrary((void*)IntuitionBase); IntuitionBase = NULL;}
    if(GfxBase) {CloseLibrary((void*)GfxBase); GfxBase = NULL;}
}

void inisound(void)
{
    iosent = 0;
    AudioMP = (void*)CreateMsgPort();
    if(!AudioMP) return;
    AudioIO = (void *)CreateExtIO(AudioMP,sizeof(struct IOAudio));
    if(!AudioIO) return;

    devopen = 0;
    AudioIO->ioa_Request.io_Message.mn_Node.ln_Pri = 127;
    AudioIO->ioa_Data = whichchannel;
    AudioIO->ioa_Length = sizeof(whichchannel);
    AudioIO->ioa_AllocKey = 0;
    if(OpenDevice(AUDIONAME, 0, (void*)AudioIO, 0)) return;
    devopen = 1;

    audiobuf = (void *)AllocMem(2,MEMF_CHIP|MEMF_CLEAR);

    if(audiobuf) {
        AudioIO->ioa_Request.io_Command = CMD_WRITE;
        AudioIO->ioa_Request.io_Flags   = ADIOF_PERVOL|IOF_QUICK;
        AudioIO->ioa_Data               = (void*)audiobuf;
        AudioIO->ioa_Length             = 2;
        AudioIO->ioa_Period             = 500;
        AudioIO->ioa_Volume             = 64;
        AudioIO->ioa_Cycles             = 0;
        BeginIO((void*)AudioIO);
        iosent = 1;
    }
}

void iniscreen(char *name)
{
    int k,i,j; /* int   i,j,k,l,n; */
    static struct NewScreen NewScreenStructure = {
        0,0, 320,200, 5, 0,1,
        0, CUSTOMSCREEN|SCREENQUIET|SCREENBEHIND,
        NULL, (void*)"UAE", NULL, NULL};
    static struct NewWindow NewWindowStructure = {
        0,0, 320,200, 0,1,
        IDCMP_MOUSEBUTTONS|IDCMP_RAWKEY|IDCMP_MOUSEMOVE,
        WFLG_BACKDROP|WFLG_RMBTRAP|WFLG_NOCAREREFRESH|
        WFLG_BORDERLESS|WFLG_WINDOWACTIVE|WFLG_REPORTMOUSE,
        NULL, NULL, (void*)"UAE", NULL, NULL, 5,5, 800,600,
        CUSTOMSCREEN};

    atexit(gfxleave);

    IntuitionBase = (void*)OpenLibrary("intuition.library",0);
    if(!IntuitionBase) {
        fprintf(stderr,"No intuition ?\n");
        exit(0);
    }

    GfxBase = (void*)OpenLibrary("graphics.library",0);
    if(!GfxBase) {
        fprintf(stderr,"No gfx ?\n");
        exit(0);
    }

    S = (void*)OpenScreen(&NewScreenStructure);
    if(!S) {
        fprintf(stderr,"No screen ?\n");
        exit(0);
    }

    NewWindowStructure.Width  = S->Width;
    NewWindowStructure.Height = S->Height;
    NewWindowStructure.Screen = S;
    W = (void*)OpenWindow(&NewWindowStructure);
    if(!W) {
        fprintf(stderr,"No window ?\n");
        exit(0);
    }

    for(i=0;i<16;++i) SetRGB4(&S->ViewPort,i,0,0,0);
    for(i=0;i<16;++i) SetRGB4(&S->ViewPort,i+16,pal[i]>>8,(pal[i]>>4)&15,pal[i]&15);

    SetAPen(&S->RastPort, 16);
    RectFill(&S->RastPort,0,0,319,199);

    for(j=0;j<16;++j) for(i=0;i<16;++i) for(k=0;k<4;++k) {
        decode[j*8+(i&7)+(i&8)*16][k] =
            (((j>>k)&1)<<1) | ((i>>k)&1);
    }

    inikey(name);
    inicray();
    inik7();
    lasttour=4;

    inisound();

    i = 0;
    j = clock();while(clock()==j);
    j = clock();while(clock()-j<CLOCKS_PER_SEC) ++i;
    j = ((35*i)/22000)-21;
    if(j>0) {
        nbwait = j;
        printf("default speed = %d\n",j);
    }
}

static void updt(int k)
{
    unsigned char *dec;
    unsigned char  frm;
    unsigned char **bm;
    unsigned char cmd;
    unsigned short j;

    k &= 0x1fff;
    if(k>=8000) return;
    frm = buf[0x04000+k];
    dec = decode[(unsigned char)buf[0x10000+k]];
    bm  = &S->RastPort.BitMap->Planes[0];
    for(j=4;j--;) {
      if(!(cmd=*dec++)) (*bm++)[k] = 0x00;
      else if(!--cmd)   (*bm++)[k] = ~frm;
      else if(!--cmd)   (*bm++)[k] =  frm;
      else              (*bm++)[k] = 0xFF;
    }
}

static void tour(int cl)
{
    cl=((cl&0x70)>>4)+((cl&4)<<1);
    SetRGB4(&S->ViewPort,0,pal[cl]>>8,(pal[cl]>>4)&15,pal[cl]&15);
}

void refreshv(void)
{
#if 0
    unsigned char  *fr  = &buf[0x04000];
    unsigned char  *fd  = &buf[0x10000];
    unsigned char  *mod = modif;
    unsigned char **bm  = &S->RastPort.BitMap->Planes[0];
    short i;

/*    WaitBOVP(&S->ViewPort);/**/
    for(i=0;i<8000;++i) if(*mod++) {
        unsigned char *dec = decode[*fd++];
        unsigned char cmd, frm = *fr++;
        unsigned short j;
        mod[-1] = 0;
        for(j=4;j--;) {
            if(!(cmd=*dec++)) (*bm++)[i] = 0x00;
            else if(!--cmd)   (*bm++)[i] = ~frm;
            else if(!--cmd)   (*bm++)[i] = frm;
            else              (*bm++)[i] = 0xFF;
        }
        bm -= 4;
    } else fd++,fr++;

  if ((modegraph)&&(lasttour!=(buf[0xe7c3]&0x74)))
    {
      int cl;
      lasttour=(buf[0xe7c3]&0x74);
      cl=(lasttour&0x70)+((lasttour&4)<<5);
      cl=cl>>4;
      SetRGB4(&S->ViewPort,0,pal[cl]>>8,(pal[cl]>>4)&15,pal[cl]&15);
    }
#endif
}

void refreshsc(void)
{
  /* int   i;

  for(i=0;i<8192;i++) modif[i]=1; */
  lasttour=4;
  refreshv();
}

long loads(long k)
{
  int i,pb; /* j */
  unsigned char *BUF=buf;

  if ((k&0xffc0)==0xe7C0)
    {               /* gestion des io       */
      switch(k&0xFF) {
      case 0xc0: return 0x81;
      case 0xc8:
          if(buf[0xe7ca]&4) {
              pb=(0x80>>(pbout1&7));
              pain1=0xff;
              for(i=0;i<nkey;i++)
                pain1&=((pb&lkey[tch[i]])?ckey[tch[i]]:0xff);
              return ((paout1&BUF[0xe7c8])+(pain1&(~BUF[0xe7c8])))&255;
          } break;
      case 0xc9: if(BUF[0xe7cb]&4)
            return ((pbout1&BUF[0xe7c9])+(pbin1&(~BUF[0xe7c9])))&255;
            break;
      case 0xca: return (BUF[0xe7ca]&0x7f)+(crain1&0x80);
      case 0xcb: return (BUF[0xe7cb]&0x7f)+(crbin1&0x80);
      case 0xcc: if(BUF[0xe7ce]&4)
            return ((paout2&BUF[0xe7cc])+(pain2&(~BUF[0xe7cc])))&255;
            break;
      case 0xcd: if(buf[0xe7cf]&4)
            return ((pbout2&BUF[0xe7cd])+(pbin2&(~BUF[0xe7cd])))&255;
            break;
      case 0xce: return (BUF[0xe7ce]&0x7f)+(crain2&0x80);
      case 0xcf: return (BUF[0xe7cf]&0x7f)+(crbin2&0x80);
      case 0xe7:
          if (gainit>=6666) gainit-=6666;
          if (gainit>=4266) return 0;
          return 128;
      }
      return buf[k]&255;
    }
  else if ((k>=0xa000)&&(k<0xe000))
    {
      i=0;
      if (BUF[0xe7c9]&8)    i|=BUF[k];
      if (BUF[0xe7c9]&0x10) i|=BUF[k+0x8000];
      if (BUF[0xe7c9]&0x18) return i&255;
      return 0x5e;
    }
  else if (((k&0xe000)==0x4000)&&(!(BUF[0xe7c3]&1))) k+=0xc000;
  return BUF[k]&255;
}

long loadl(long k)
{
  int i;
  unsigned char *BUF=buf;

  if ((k&0xffc0)==0xe7C0)
    {               /* gestion des io       */
      return ((loads(k)<<8)+(loads(k+1)&255))&0xffff;
    }
  if ((k>=0xa000)&&(k<0xe000))
    {
      i=0;
      if (BUF[0xe7c9]&8)    i|=get_short(BUF+k);
      if (BUF[0xe7c9]&0x10) i|=get_short(BUF+k+0x8000);
      if (BUF[0xe7c9]&0x18) return i&0xffff;
      return 0x5e5e;
    }
  if (((k&0xe000)==0x4000)&&(!(BUF[0xe7c3]&1))) k+=0xc000;
  return get_short(BUF+k);
}

/*__inline__ int stocs(long k,long val) */
int stocs(long k,long val)
{
  unsigned char *BUF=buf;
  if (k<0x6000)
    {
      if (k<0x4000) return 0;
      if (!(BUF[0xe7c3]&1)) k+=0xc000;
      BUF[k]=val;
      updt(k);
      return 0;
    }
  if (k>endmem)
    {
      if ((k&0xffc0)==0xe7C0)
        {
          switch(k&15) {
          /* e7c1 */
          case 0x0: break;
          case 0x1: if(iosent) *audiobuf = (val&8)?0x8080:0x7F7F; break;
          case 0x2: break;
          case 0x3: val |= 128; tour(val); break;
          case 0x4: case 0x5: case 0x6: case 0x7: break;
          case 0x8: if(BUF[0xe7ca]&4) {paout1=val;return 0;} break;
          case 0x9: if(BUF[0xe7cb]&4) {pbout1=val;return 0;} break;
          case 0xa: case 0xb: break;
          case 0xc: if(BUF[0xe7ce]&4) {paout2=val;return 0;} break;
          case 0xd: if(BUF[0xe7cf]&4) {pbout2=val;return 0;} break;
          case 0xe: case 0xf: break;
          }
          BUF[k]=val;
        }
      return 0;
    }

  if (k>=0xa000)
    {
      if (BUF[0xe7c9]&8)    BUF[k]=val;
      if (BUF[0xe7c9]&0x10) BUF[k+0x8000]=val;
      return 0;
    }
  BUF[k]=val;
  return 0;
}

int stocl(long k,long val)
{
  unsigned char *BUF=buf;
  if (k<0x6000)
    {

      if (k<0x4000) return 0;
      if (!(BUF[0xe7c3]&1)) k+=0xc000;
      *(short*)&BUF[k]=val;
      updt(k);updt(k+1);
      return 0;
    }
  else if (k>endmem)
    {
      if ((k&0xffc0)==0xe7C0)
        {               /* gestion des io       */
          stocs(k,val>>8);
          stocs(k+1,val);
        }
      return 0;
    }
  else if (k>=0xa000)
    {
      if (BUF[0xe7c9]&8)    *(short*)&BUF[k]=val;
      if (BUF[0xe7c9]&0x10) *(short*)&BUF[k+0x8000]=val;
      return 0;
    }
  *(short*)&BUF[k]=val;
  return 0;
}


long    compt;
int     quitf;

int bouclex(void)
{
  struct IntuiMessage *msg;
  int   i,j,k;
  int   key;
  int   ninst;

  j=0;
  compt=0;
  for(i=0;i<nkey;i++) tch[i]=0;
  quitf=1;

  pain2=paout2=crain2=255;
  pbin2=pbout2=crbin2=255;

  gainit=0;
  ninst=0;

  ScreenToFront(W->WScreen);

  while(quitf)
    {
      for(i=0;i<11000;i++)
        {
          exe6809(); /* attendre faut s'arranger pour durer 1/330000sec=3µsec*/
          for(k=0;k<nbwait;k++);
          gainit++;
        }
      if (gainit>=6666) gainit-=6666;

      if ((++j)==3)
        {
          if (!(ccrest&0x10))
            {
              static clock_t lastt;
              if(lastt) {
                  clock_t t = clock();
                  int r = 1;
                  if(!nbwait && ((t-lastt)*10<CLOCKS_PER_SEC)) nbwait = 1;
                  r = (nbwait*(CLOCKS_PER_SEC+1))/(10*(t-lastt)+1);
                  if(r!=nbwait) {
                      printf("New speed=%d\n",r);
                      nbwait = r;
                  }
                  lastt = t;
              } else lastt = clock();
              ccrest|=0x80;
              pshsr(0xff);
              ccrest|=0x10;
              pc=((buf[0xfff8]<<8)+(buf[0xfff9]&255))&0xffff;
            }
          j=0;
        }
      refreshv();
      if(SetSignal(0L, SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D) &
                    (SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D)) {
         raise(SIGINT);
      }
      while(msg=(void*)GetMsg(W->UserPort))
        {
            int x,y,class,code;
            class = msg->Class;
            code  = msg->Code;
            x     = msg->MouseX;
            y     = msg->MouseY;
            ReplyMsg((struct Message*)msg);

            switch(class) {
            case IDCMP_MOUSEBUTTONS:
                crayx = x;
                crayy = y;
                if(code==SELECTDOWN) buf[0xE7C3] |= 2;
                if(code==SELECTUP)   buf[0xE7C3] &=~2;
                if(code==MENUDOWN)   quitf=0;
                if(code==MENUUP)     quitf=1;
            break;

            case IDCMP_MOUSEMOVE:
                crayx = x;
                crayy = y;
            break;

            case IDCMP_RAWKEY:
                key = code&127;
                if(code&128) { /* release */
                    if (lkey[key]) {
                        for(i=0;i<nkey;i++) if (tch[i]==key) tch[i]=0;
                    } else if ((i=ckey[key])!=255) {
                        if (i<0xfd) pain2|=i;
                        if (i==0xfe) {pbin2|=0x40;crain2|=0x80;}
                        if (i==0xfd) {pbin2|=0x80;crbin2|=0x80;}
                    }
                } else {       /* press */
                    if (lkey[key]) {
                        i=0;
                        while((i<nkey)&&(tch[i]!=key)) i++;
                        if (i==nkey) {
                            i=0;
                            while((i<nkey)&&(tch[i])) i++;
                            if (i==nkey) i=0;
                            tch[i]=key;
                        }
                    } else if ((i=ckey[key])!=255) {
                        if (i==0xfe) {pbin2&=0xbf;crain2&=0x7f;}
                        if (i==0xfd) {pbin2&=0x7f;crbin2&=0x7f;}
                        if (i<0xfd) pain2&=~i;
                    }
                }
            break;
            }
        }
    }

  ScreenToBack(W->WScreen);

  return ninst;
}

